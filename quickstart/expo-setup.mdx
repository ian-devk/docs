---
title: "Expo Setup"
description: "Configure Expo SDK 52+ with React Native 0.74+ New Architecture for production-ready safety applications. Includes Express.js backend integration, state management, and performance optimization."
---

# Production Expo Setup for Safety Apps

<Info>
**Enterprise-Grade Configuration:** This guide configures Expo SDK 52+ with React Native's New Architecture for production safety applications, including Express.js backend integration, advanced state management, and performance optimization.
</Info>

## Architecture Overview

Shelther's client architecture leverages the latest React Native capabilities:

<CardGroup cols={2}>
  <Card title="New Architecture (Bridgeless)" icon="chip">
    React Native 0.74+ with New Architecture enabled by default for 40% better performance
  </Card>
  <Card title="Express.js Backend Integration" icon="server">
    Production API client with JWT authentication and real-time WebSocket connections
  </Card>
  <Card title="Advanced State Management" icon="database">
    Redux Toolkit with React Query for optimized caching and offline-first architecture
  </Card>
  <Card title="Battery-Optimized Background Tasks" icon="battery-full">
    Intelligent background processing with adaptive polling for extended battery life
  </Card>
</CardGroup>

## Project Initialization

### Create Production-Ready Expo Project

<CodeGroup>
```bash Initialize New Project
# Create Expo project with New Architecture enabled
npx create-expo-app ShelterSafetyApp --template blank-typescript

cd ShelterSafetyApp

# Install core dependencies for production safety app
npm install @supabase/supabase-js@^2.38.0 \
            @react-native-async-storage/async-storage@~1.21.0 \
            @reduxjs/toolkit@^2.0.1 \
            react-redux@^9.0.4 \
            @tanstack/react-query@^5.17.0 \
            react-native-mmkv@^2.11.0

# Add Expo-specific safety dependencies
npx expo install expo-location@~17.0.0 \
                 expo-notifications@~0.28.0 \
                 expo-background-task@~12.0.0 \
                 expo-sensors@~13.0.0 \
                 expo-secure-store@~13.0.0 \
                 expo-video@~2.0.0 \
                 expo-audio@~1.0.0

# Add network and API dependencies
npm install axios@^1.6.0 \
            @tanstack/react-query-devtools@^5.17.0 \
            react-native-get-random-values@~1.9.0 \
            react-native-url-polyfill@^2.0.0

# Development and testing tools
npm install --save-dev @testing-library/react-native@^12.4.0 \
                       @testing-library/jest-native@^5.4.3 \
                       react-native-testing-library@^6.0.0 \
                       detox@^20.13.0
```

```bash Clone Official Shelther Template
# Clone the production-ready template
git clone https://github.com/shelther/expo-production-template.git
cd expo-production-template

# Install dependencies
npm install

# Set up environment configuration
cp .env.example .env.local
npm run setup:dev
```
</CodeGroup>

### Enhanced Package Configuration

<CodeGroup>
```json package.json - Production Dependencies
{
  "name": "shelther-safety-app",
  "version": "1.0.0",
  "main": "expo-router/entry",
  "scripts": {
    "start": "expo start",
    "start:dev": "expo start --dev-client",
    "start:prod": "expo start --no-dev --minify",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "build:android": "eas build --platform android",
    "build:ios": "eas build --platform ios",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:e2e": "detox test",
    "lint": "eslint . --ext .ts,.tsx,.js,.jsx",
    "type-check": "tsc --noEmit",
    "prebuild": "expo prebuild --clean"
  },
  "dependencies": {
    "@expo/metro-config": "~0.17.0",
    "@react-native-async-storage/async-storage": "~1.21.0",
    "@reduxjs/toolkit": "^2.0.1",
    "@supabase/supabase-js": "^2.38.0",
    "@tanstack/react-query": "^5.17.0",
    "axios": "^1.6.0",
    "expo": "~52.0.0",
    "expo-audio": "~1.0.0",
    "expo-background-task": "~12.0.0",
    "expo-constants": "~16.0.0",
    "expo-device": "~6.0.0",
    "expo-font": "~12.0.0",
    "expo-linking": "~7.0.0",
    "expo-location": "~17.0.0",
    "expo-notifications": "~0.28.0",
    "expo-router": "~3.5.0",
    "expo-secure-store": "~13.0.0",
    "expo-sensors": "~13.0.0",
    "expo-splash-screen": "~0.29.0",
    "expo-status-bar": "~2.0.0",
    "expo-video": "~2.0.0",
    "react": "18.2.0",
    "react-native": "0.74.5",
    "react-native-get-random-values": "~1.9.0",
    "react-native-mmkv": "^2.11.0",
    "react-native-reanimated": "~3.16.0",
    "react-native-safe-area-context": "~4.12.0",
    "react-native-screens": "~4.0.0",
    "react-native-url-polyfill": "^2.0.0",
    "react-redux": "^9.0.4"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@expo/config-plugins": "~8.0.0",
    "@tanstack/react-query-devtools": "^5.17.0",
    "@testing-library/jest-native": "^5.4.3",
    "@testing-library/react-native": "^12.4.0",
    "@types/jest": "^29.5.5",
    "@types/react": "~18.2.45",
    "@typescript-eslint/eslint-plugin": "^7.7.0",
    "@typescript-eslint/parser": "^7.7.0",
    "detox": "^20.13.0",
    "eslint": "^8.57.0",
    "eslint-config-expo": "^7.0.0",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.0",
    "prettier": "^3.0.0",
    "typescript": "~5.3.3"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```
</CodeGroup>

## App Configuration (app.json)

### Production-Ready App Configuration

<CodeGroup>
```json app.json - Complete Configuration
{
  "expo": {
    "name": "Shelther Safety",
    "slug": "shelther-safety",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "shelther",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/images/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#8B5CF6"
    },
    "assetBundlePatterns": ["**/*"],
    "ios": {
      "googleServicesFile": "./ios/GoogleService-Info.plist",
      "supportsTablet": true,
      "bundleIdentifier": "com.shelther.safety",
      "buildNumber": "1.0.0",
      "deploymentTarget": "15.1",
      "infoPlist": {
        "NSLocationWhenInUseUsageDescription": "Shelther monitors your location during safety activities to protect you and alert your Circle of Trust in emergencies. Your location is encrypted and only shared with people you explicitly trust.",
        "NSLocationAlwaysAndWhenInUseUsageDescription": "Shelther uses background location tracking to provide continuous safety monitoring, detect potential emergencies, and automatically check if you arrive safely at your destinations.",
        "NSLocationAlwaysUsageDescription": "Shelther requires always-on location access to provide reliable safety monitoring during activities, detect anomalies in your movement patterns, and ensure emergency alerts include accurate location information.",
        "NSCameraUsageDescription": "Shelther uses the camera to capture evidence during emergency situations and allow you to share your current surroundings with trusted contacts for enhanced safety verification.",
        "NSMicrophoneUsageDescription": "Shelther may record ambient audio during emergency situations to provide context to emergency responders and trusted contacts. Audio recordings are encrypted and automatically deleted after resolution.",
        "NSPhotoLibraryUsageDescription": "Shelther allows you to select photos for your profile and save emergency evidence to your photo library for personal records and potential law enforcement use.",
        "NSContactsUsageDescription": "Shelther accesses your contacts to help you quickly find and add trusted emergency contacts to your Circle of Trust safety network.",
        "NSFaceIDUsageDescription": "Use Face ID to quickly and securely access emergency features during high-stress situations, ensuring rapid response when every second counts.",
        "NSUserNotificationsUsageDescription": "Shelther sends critical safety notifications including check-in reminders, emergency alerts to your network, and location-based safety warnings to keep you and your contacts informed.",
        "UIBackgroundModes": [
          "location",
          "background-fetch",
          "background-processing",
          "audio",
          "background-app-refresh"
        ],
        "BGTaskSchedulerPermittedIdentifiers": [
          "com.shelther.safety.background-location",
          "com.shelther.safety.emergency-monitor",
          "com.shelther.safety.checkin-monitor",
          "com.shelther.safety.data-sync",
          "com.shelther.safety.battery-optimization"
        ],
        "NSAppTransportSecurity": {
          "NSAllowsArbitraryLoads": false,
          "NSExceptionDomains": {
            "api.shelther.app": {
              "NSExceptionAllowsInsecureHTTPLoads": false,
              "NSExceptionMinimumTLSVersion": "TLSv1.2",
              "NSIncludesSubdomains": true
            }
          }
        }
      }
    },
    "android": {
      "googleServicesFile": "./android/app/google-services.json",
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#8B5CF6"
      },
      "package": "com.shelther.safety",
      "versionCode": 1,
      "compileSdkVersion": 35,
      "targetSdkVersion": 35,
      "permissions": [
        "ACCESS_COARSE_LOCATION",
        "ACCESS_FINE_LOCATION",
        "ACCESS_BACKGROUND_LOCATION",
        "CAMERA",
        "RECORD_AUDIO",
        "READ_EXTERNAL_STORAGE",
        "WRITE_EXTERNAL_STORAGE",
        "READ_MEDIA_IMAGES",
        "READ_MEDIA_AUDIO",
        "READ_MEDIA_VIDEO",
        "READ_CONTACTS",
        "VIBRATE",
        "WAKE_LOCK",
        "RECEIVE_BOOT_COMPLETED",
        "FOREGROUND_SERVICE",
        "FOREGROUND_SERVICE_LOCATION",
        "FOREGROUND_SERVICE_DATA_SYNC",
        "POST_NOTIFICATIONS",
        "USE_BIOMETRIC",
        "USE_FINGERPRINT",
        "INTERNET",
        "ACCESS_NETWORK_STATE",
        "ACCESS_WIFI_STATE"
      ],
      "blockedPermissions": [
        "READ_PHONE_STATE",
        "CALL_PHONE",
        "READ_SMS",
        "SEND_SMS",
        "READ_CALENDAR",
        "WRITE_CALENDAR"
      ]
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-location",
        {
          "locationAlwaysAndWhenInUsePermission": "Shelther requires location access to provide safety monitoring and emergency response.",
          "locationAlwaysPermission": "Shelther uses background location to detect emergencies and ensure your safety during activities.",
          "locationWhenInUsePermission": "Shelther monitors your location during safety activities to protect you and alert trusted contacts.",
          "isIosBackgroundLocationEnabled": true,
          "isAndroidBackgroundLocationEnabled": true,
          "isAndroidForegroundServiceEnabled": true
        }
      ],
      [
        "expo-notifications",
        {
          "icon": "./assets/images/notification-icon.png",
          "color": "#8B5CF6",
          "defaultChannel": "emergency-alerts",
          "sounds": [
            "./assets/sounds/emergency-alert.wav",
            "./assets/sounds/check-in-reminder.wav",
            "./assets/sounds/safety-warning.wav"
          ]
        }
      ],
      [
        "expo-build-properties",
        {
          "android": {
            "compileSdkVersion": 35,
            "targetSdkVersion": 35,
            "buildToolsVersion": "35.0.0",
            "minSdkVersion": 24,
            "newArchEnabled": true,
            "proguardMinifyEnabled": true,
            "enableProguardInReleaseBuilds": true,
            "enableHermes": true
          },
          "ios": {
            "deploymentTarget": "15.1",
            "newArchEnabled": true,
            "flipper": false
          }
        }
      ],
      [
        "expo-secure-store",
        {
          "faceIDPermission": "Use Face ID to quickly access emergency features during critical situations."
        }
      ],
      "expo-background-task"
    ],
    "experiments": {
      "typedRoutes": true,
      "tsconfigPaths": true
    },
    "extra": {
      "router": {
        "origin": false
      },
      "eas": {
        "projectId": "your-eas-project-id"
      }
    }
  }
}
```
</CodeGroup>

## Express.js Backend Integration

### API Client Configuration

<CodeGroup>
```typescript API Client Setup
// lib/api/client.ts
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { storage } from './storage';
import { refreshAuthToken } from './auth';

const API_BASE_URL = process.env.EXPO_PUBLIC_API_URL || 'https://api.shelther.app';
const API_TIMEOUT = 10000; // 10 seconds

class APIClient {
  private client: AxiosInstance;
  private isRefreshing = false;
  private failedQueue: Array<{
    resolve: (token: string) => void;
    reject: (error: any) => void;
  }> = [];

  constructor() {
    this.client = axios.create({
      baseURL: API_BASE_URL,
      timeout: API_TIMEOUT,
      headers: {
        'Content-Type': 'application/json',
        'X-Client-Platform': 'react-native',
        'X-Client-Version': '1.0.0',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // Request interceptor for auth tokens
    this.client.interceptors.request.use(
      async (config) => {
        const token = await storage.getSecureItem('auth_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        
        // Add correlation ID for request tracking
        config.headers['X-Correlation-ID'] = this.generateCorrelationId();
        
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor for token refresh
    this.client.interceptors.response.use(
      (response) => response,
      async (error) => {
        const original = error.config;

        if (error.response?.status === 401 && !original._retry) {
          if (this.isRefreshing) {
            return new Promise((resolve, reject) => {
              this.failedQueue.push({ resolve, reject });
            }).then((token) => {
              original.headers.Authorization = `Bearer ${token}`;
              return this.client(original);
            });
          }

          original._retry = true;
          this.isRefreshing = true;

          try {
            const newToken = await refreshAuthToken();
            this.isRefreshing = false;
            this.processQueue(null, newToken);
            original.headers.Authorization = `Bearer ${newToken}`;
            return this.client(original);
          } catch (refreshError) {
            this.isRefreshing = false;
            this.processQueue(refreshError, null);
            // Redirect to login
            throw refreshError;
          }
        }

        return Promise.reject(error);
      }
    );
  }

  private processQueue(error: any, token: string | null) {
    this.failedQueue.forEach(({ resolve, reject }) => {
      if (error) {
        reject(error);
      } else {
        resolve(token!);
      }
    });
    
    this.failedQueue = [];
  }

  private generateCorrelationId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  // Emergency API calls with priority handling
  async emergencyRequest<T>(config: AxiosRequestConfig): Promise<T> {
    const emergencyConfig = {
      ...config,
      timeout: 5000, // Shorter timeout for emergency calls
      headers: {
        ...config.headers,
        'X-Priority': 'emergency',
        'X-Retry-Count': '3',
      },
    };

    let attempts = 0;
    const maxAttempts = 3;

    while (attempts < maxAttempts) {
      try {
        const response = await this.client(emergencyConfig);
        return response.data;
      } catch (error) {
        attempts++;
        if (attempts >= maxAttempts) {
          throw error;
        }
        // Exponential backoff for retries
        await this.delay(Math.pow(2, attempts) * 1000);
      }
    }

    throw new Error('Emergency request failed after maximum retries');
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Standard API methods
  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.get(url, config);
    return response.data;
  }

  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.post(url, data, config);
    return response.data;
  }

  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.put(url, data, config);
    return response.data;
  }

  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.delete(url, config);
    return response.data;
  }
}

export const apiClient = new APIClient();
```

```typescript Emergency API Service
// lib/api/emergency.ts
import { apiClient } from './client';
import { EmergencyAlert, LocationData } from '../types';

export interface TriggerEmergencyRequest {
  alertType: 'manual' | 'duress' | 'check_in_missed';
  triggerMethod?: 'button' | 'shake' | 'widget' | 'auto';
  location?: LocationData;
  message?: string;
  evidence?: {
    audioUri?: string;
    photoUris?: string[];
    videoUri?: string;
  };
}

export interface EmergencyResponse {
  alertId: string;
  status: 'active' | 'acknowledged' | 'resolved';
  contactsNotified: number;
  estimatedResponseTime: number;
}

class EmergencyService {
  async triggerEmergencyAlert(data: TriggerEmergencyRequest): Promise<EmergencyResponse> {
    return apiClient.emergencyRequest<EmergencyResponse>({
      method: 'POST',
      url: '/api/v1/emergency/trigger',
      data,
    });
  }

  async resolveEmergencyAlert(
    alertId: string,
    resolution: 'resolved' | 'false_alarm',
    message?: string
  ): Promise<void> {
    return apiClient.emergencyRequest<void>({
      method: 'PATCH',
      url: `/api/v1/emergency/${alertId}/resolve`,
      data: { resolution, message },
    });
  }

  async getActiveAlerts(): Promise<EmergencyAlert[]> {
    return apiClient.get<EmergencyAlert[]>('/api/v1/emergency/active');
  }

  async acknowledgeAlert(alertId: string): Promise<void> {
    return apiClient.post<void>(`/api/v1/emergency/${alertId}/acknowledge`);
  }

  async uploadEmergencyEvidence(
    alertId: string,
    evidence: FormData
  ): Promise<{ uploadUrls: string[] }> {
    return apiClient.emergencyRequest<{ uploadUrls: string[] }>({
      method: 'POST',
      url: `/api/v1/emergency/${alertId}/evidence`,
      data: evidence,
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
  }
}

export const emergencyService = new EmergencyService();
```
</CodeGroup>

### Real-time WebSocket Integration

<CodeGroup>
```typescript WebSocket Client
// lib/realtime/websocket.ts
import { storage } from '../storage';

export interface WebSocketMessage {
  type: string;
  payload: any;
  timestamp: number;
  correlationId?: string;
}

export interface WebSocketConfig {
  url: string;
  reconnectInterval: number;
  maxReconnectAttempts: number;
  heartbeatInterval: number;
}

class WebSocketClient {
  private ws: WebSocket | null = null;
  private config: WebSocketConfig;
  private reconnectAttempts = 0;
  private isConnecting = false;
  private messageQueue: WebSocketMessage[] = [];
  private heartbeatTimer?: NodeJS.Timeout;
  private reconnectTimer?: NodeJS.Timeout;
  private eventListeners: Map<string, Set<(data: any) => void>> = new Map();

  constructor(config?: Partial<WebSocketConfig>) {
    this.config = {
      url: process.env.EXPO_PUBLIC_WS_URL || 'wss://realtime.shelther.app',
      reconnectInterval: 5000,
      maxReconnectAttempts: 10,
      heartbeatInterval: 30000,
      ...config,
    };
  }

  async connect(): Promise<void> {
    if (this.isConnecting || this.isConnected()) {
      return;
    }

    this.isConnecting = true;

    try {
      const token = await storage.getSecureItem('auth_token');
      const wsUrl = `${this.config.url}?token=${token}`;
      
      this.ws = new WebSocket(wsUrl);
      
      this.ws.onopen = this.handleOpen.bind(this);
      this.ws.onmessage = this.handleMessage.bind(this);
      this.ws.onclose = this.handleClose.bind(this);
      this.ws.onerror = this.handleError.bind(this);
      
    } catch (error) {
      this.isConnecting = false;
      console.error('WebSocket connection failed:', error);
      this.scheduleReconnect();
    }
  }

  private handleOpen(): void {
    console.log('WebSocket connected');
    this.isConnecting = false;
    this.reconnectAttempts = 0;
    
    // Send queued messages
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift();
      if (message) {
        this.send(message);
      }
    }
    
    // Start heartbeat
    this.startHeartbeat();
    
    // Subscribe to emergency channels
    this.subscribe('user:emergency-alerts');
    this.subscribe('user:location-updates');
    this.subscribe('user:check-in-reminders');
  }

  private handleMessage(event: MessageEvent): void {
    try {
      const message: WebSocketMessage = JSON.parse(event.data);
      
      if (message.type === 'pong') {
        return; // Heartbeat response
      }
      
      const listeners = this.eventListeners.get(message.type);
      if (listeners) {
        listeners.forEach(listener => {
          try {
            listener(message.payload);
          } catch (error) {
            console.error('WebSocket event listener error:', error);
          }
        });
      }
      
    } catch (error) {
      console.error('WebSocket message parsing error:', error);
    }
  }

  private handleClose(event: CloseEvent): void {
    console.log('WebSocket disconnected:', event.code, event.reason);
    this.cleanup();
    
    // Attempt reconnection unless it was a clean close
    if (event.code !== 1000) {
      this.scheduleReconnect();
    }
  }

  private handleError(error: Event): void {
    console.error('WebSocket error:', error);
  }

  private scheduleReconnect(): void {
    if (this.reconnectAttempts >= this.config.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      return;
    }
    
    const delay = Math.min(
      this.config.reconnectInterval * Math.pow(2, this.reconnectAttempts),
      30000 // Max 30 seconds
    );
    
    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempts++;
      console.log(`Reconnecting attempt ${this.reconnectAttempts}/${this.config.maxReconnectAttempts}`);
      this.connect();
    }, delay);
  }

  private startHeartbeat(): void {
    this.heartbeatTimer = setInterval(() => {
      if (this.isConnected()) {
        this.send({
          type: 'ping',
          payload: {},
          timestamp: Date.now(),
        });
      }
    }, this.config.heartbeatInterval);
  }

  private cleanup(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = undefined;
    }
    
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = undefined;
    }
    
    this.ws = null;
    this.isConnecting = false;
  }

  send(message: WebSocketMessage): void {
    if (this.isConnected()) {
      this.ws!.send(JSON.stringify(message));
    } else {
      // Queue message for when connection is restored
      this.messageQueue.push(message);
      if (!this.isConnecting) {
        this.connect();
      }
    }
  }

  subscribe(channel: string): void {
    this.send({
      type: 'subscribe',
      payload: { channel },
      timestamp: Date.now(),
    });
  }

  unsubscribe(channel: string): void {
    this.send({
      type: 'unsubscribe',
      payload: { channel },
      timestamp: Date.now(),
    });
  }

  on(eventType: string, listener: (data: any) => void): void {
    if (!this.eventListeners.has(eventType)) {
      this.eventListeners.set(eventType, new Set());
    }
    this.eventListeners.get(eventType)!.add(listener);
  }

  off(eventType: string, listener: (data: any) => void): void {
    const listeners = this.eventListeners.get(eventType);
    if (listeners) {
      listeners.delete(listener);
    }
  }

  isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }

  disconnect(): void {
    if (this.ws) {
      this.ws.close(1000, 'Client disconnecting');
    }
    this.cleanup();
  }
}

export const wsClient = new WebSocketClient();
```
</CodeGroup>

## Advanced State Management

### Redux Toolkit with React Query Integration

<CodeGroup>
```typescript Store Configuration
// lib/store/index.ts
import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import { persistStore, persistReducer, FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER } from 'redux-persist';
import { MMKV } from 'react-native-mmkv';

import { authSlice } from './slices/authSlice';
import { emergencySlice } from './slices/emergencySlice';
import { locationSlice } from './slices/locationSlice';
import { settingsSlice } from './slices/settingsSlice';
import { api } from './api';

// MMKV storage for Redux Persist
const storage = new MMKV({ id: 'redux-storage' });

const reduxStorage = {
  setItem: (key: string, value: string) => {
    storage.set(key, value);
    return Promise.resolve(true);
  },
  getItem: (key: string) => {
    const value = storage.getString(key);
    return Promise.resolve(value);
  },
  removeItem: (key: string) => {
    storage.delete(key);
    return Promise.resolve();
  },
};

// Persist configurations
const authPersistConfig = {
  key: 'auth',
  storage: reduxStorage,
  whitelist: ['user', 'isAuthenticated', 'preferences'],
};

const settingsPersistConfig = {
  key: 'settings',
  storage: reduxStorage,
  whitelist: ['emergencyContacts', 'locationSettings', 'notificationSettings'],
};

const emergencyPersistConfig = {
  key: 'emergency',
  storage: reduxStorage,
  whitelist: ['offlineAlerts', 'lastKnownLocation'],
};

export const store = configureStore({
  reducer: {
    auth: persistReducer(authPersistConfig, authSlice.reducer),
    emergency: persistReducer(emergencyPersistConfig, emergencySlice.reducer),
    location: locationSlice.reducer, // Don't persist sensitive location data
    settings: persistReducer(settingsPersistConfig, settingsSlice.reducer),
    api: api.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
      },
    })
    .concat(api.middleware),
  devTools: __DEV__,
});

export const persistor = persistStore(store);

// Enable listener behavior for the store
setupListeners(store.dispatch);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

```typescript React Query API Slice
// lib/store/api.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import type { RootState } from './index';
import { storage } from '../storage';

const baseQuery = fetchBaseQuery({
  baseUrl: process.env.EXPO_PUBLIC_API_URL || 'https://api.shelther.app/api/v1',
  prepareHeaders: async (headers, { getState }) => {
    const token = await storage.getSecureItem('auth_token');
    if (token) {
      headers.set('authorization', `Bearer ${token}`);
    }
    headers.set('X-Client-Platform', 'react-native');
    headers.set('X-Client-Version', '1.0.0');
    return headers;
  },
});

const baseQueryWithReauth = async (args: any, api: any, extraOptions: any) => {
  let result = await baseQuery(args, api, extraOptions);
  
  if (result.error && result.error.status === 401) {
    // Try to refresh token
    const refreshResult = await baseQuery({
      url: '/auth/refresh',
      method: 'POST',
    }, api, extraOptions);
    
    if (refreshResult.data) {
      // Store new token and retry original request
      await storage.setSecureItem('auth_token', (refreshResult.data as any).token);
      result = await baseQuery(args, api, extraOptions);
    } else {
      // Refresh failed, redirect to login
      api.dispatch({ type: 'auth/logout' });
    }
  }
  
  return result;
};

export const api = createApi({
  reducerPath: 'api',
  baseQuery: baseQueryWithReauth,
  tagTypes: ['User', 'EmergencyAlert', 'Contact', 'Location', 'CheckIn'],
  endpoints: (builder) => ({
    // Emergency endpoints
    triggerEmergency: builder.mutation<any, any>({
      query: (data) => ({
        url: '/emergency/trigger',
        method: 'POST',
        body: data,
      }),
      invalidatesTags: ['EmergencyAlert'],
    }),
    
    getActiveAlerts: builder.query<any[], void>({
      query: () => '/emergency/active',
      providesTags: ['EmergencyAlert'],
      // Poll every 30 seconds for active alerts
      pollingInterval: 30000,
    }),
    
    // Contact endpoints
    getEmergencyContacts: builder.query<any[], void>({
      query: () => '/contacts/emergency',
      providesTags: ['Contact'],
    }),
    
    addEmergencyContact: builder.mutation<any, any>({
      query: (contact) => ({
        url: '/contacts/emergency',
        method: 'POST',
        body: contact,
      }),
      invalidatesTags: ['Contact'],
    }),
    
    // Location endpoints
    updateLocation: builder.mutation<void, any>({
      query: (location) => ({
        url: '/location/update',
        method: 'POST',
        body: location,
      }),
      invalidatesTags: ['Location'],
    }),
    
    // Check-in endpoints
    scheduleCheckIn: builder.mutation<any, any>({
      query: (checkIn) => ({
        url: '/checkin/schedule',
        method: 'POST',
        body: checkIn,
      }),
      invalidatesTags: ['CheckIn'],
    }),
    
    completeCheckIn: builder.mutation<void, string>({
      query: (checkInId) => ({
        url: `/checkin/${checkInId}/complete`,
        method: 'POST',
      }),
      invalidatesTags: ['CheckIn'],
    }),
  }),
});

export const {
  useTriggerEmergencyMutation,
  useGetActiveAlertsQuery,
  useGetEmergencyContactsQuery,
  useAddEmergencyContactMutation,
  useUpdateLocationMutation,
  useScheduleCheckInMutation,
  useCompleteCheckInMutation,
} = api;
```
</CodeGroup>

## Enhanced Background Tasks

### New Architecture Background Processing

<CodeGroup>
```typescript Modern Background Task Setup
// lib/background/tasks.ts
import * as BackgroundTask from 'expo-background-task';
import * as Location from 'expo-location';
import * as Notifications from 'expo-notifications';
import { store } from '../store';
import { updateLocationAction } from '../store/slices/locationSlice';
import { checkMissedCheckInsAction } from '../store/slices/emergencySlice';

// Background task identifiers
const BACKGROUND_TASKS = {
  LOCATION_TRACKING: 'location-tracking',
  EMERGENCY_MONITOR: 'emergency-monitor',
  CHECKIN_MONITOR: 'checkin-monitor',
  DATA_SYNC: 'data-sync',
  BATTERY_OPTIMIZATION: 'battery-optimization',
} as const;

class BackgroundTaskManager {
  private registeredTasks = new Set<string>();
  private isLocationTrackingActive = false;
  private locationConfig = {
    accuracy: Location.Accuracy.Balanced,
    timeInterval: 300000, // 5 minutes default
    distanceInterval: 100, // 100 meters
  };

  async initializeBackgroundTasks(): Promise<void> {
    try {
      // Register location tracking task
      await this.registerLocationTrackingTask();
      
      // Register emergency monitoring task
      await this.registerEmergencyMonitorTask();
      
      // Register check-in monitoring task
      await this.registerCheckInMonitorTask();
      
      // Register data sync task
      await this.registerDataSyncTask();
      
      console.log('Background tasks initialized successfully');
    } catch (error) {
      console.error('Failed to initialize background tasks:', error);
    }
  }

  private async registerLocationTrackingTask(): Promise<void> {
    if (this.registeredTasks.has(BACKGROUND_TASKS.LOCATION_TRACKING)) {
      return;
    }

    await BackgroundTask.defineTask(BACKGROUND_TASKS.LOCATION_TRACKING, async () => {
      try {
        const { granted } = await Location.getForegroundPermissionsAsync();
        if (!granted) {
          return BackgroundTask.BackgroundTaskResult.Failed;
        }

        const location = await Location.getCurrentPositionAsync(this.locationConfig);
        
        // Update store with new location
        store.dispatch(updateLocationAction({
          latitude: location.coords.latitude,
          longitude: location.coords.longitude,
          accuracy: location.coords.accuracy,
          timestamp: location.timestamp,
          batteryLevel: await getBatteryLevel(),
        }));

        // Check for emergency conditions
        await this.checkEmergencyConditions(location);
        
        // Sync location to backend if online
        await this.syncLocationUpdate(location);

        return BackgroundTask.BackgroundTaskResult.NewData;
      } catch (error) {
        console.error('Location tracking task failed:', error);
        return BackgroundTask.BackgroundTaskResult.Failed;
      }
    });

    this.registeredTasks.add(BACKGROUND_TASKS.LOCATION_TRACKING);
  }

  private async registerEmergencyMonitorTask(): Promise<void> {
    if (this.registeredTasks.has(BACKGROUND_TASKS.EMERGENCY_MONITOR)) {
      return;
    }

    await BackgroundTask.defineTask(BACKGROUND_TASKS.EMERGENCY_MONITOR, async () => {
      try {
        const state = store.getState();
        const { activeAlerts } = state.emergency;

        // Process active emergency alerts
        for (const alert of activeAlerts) {
          await this.processActiveEmergencyAlert(alert);
        }

        // Check for automatic emergency triggers
        await this.checkAutomaticEmergencyTriggers();

        return BackgroundTask.BackgroundTaskResult.NewData;
      } catch (error) {
        console.error('Emergency monitor task failed:', error);
        return BackgroundTask.BackgroundTaskResult.Failed;
      }
    });

    this.registeredTasks.add(BACKGROUND_TASKS.EMERGENCY_MONITOR);
  }

  private async registerCheckInMonitorTask(): Promise<void> {
    if (this.registeredTasks.has(BACKGROUND_TASKS.CHECKIN_MONITOR)) {
      return;
    }

    await BackgroundTask.defineTask(BACKGROUND_TASKS.CHECKIN_MONITOR, async () => {
      try {
        // Check for missed check-ins
        store.dispatch(checkMissedCheckInsAction());
        
        const state = store.getState();
        const missedCheckIns = state.emergency.missedCheckIns;

        // Process missed check-ins
        for (const checkIn of missedCheckIns) {
          await this.processMissedCheckIn(checkIn);
        }

        return BackgroundTask.BackgroundTaskResult.NewData;
      } catch (error) {
        console.error('Check-in monitor task failed:', error);
        return BackgroundTask.BackgroundTaskResult.Failed;
      }
    });

    this.registeredTasks.add(BACKGROUND_TASKS.CHECKIN_MONITOR);
  }

  private async registerDataSyncTask(): Promise<void> {
    if (this.registeredTasks.has(BACKGROUND_TASKS.DATA_SYNC)) {
      return;
    }

    await BackgroundTask.defineTask(BACKGROUND_TASKS.DATA_SYNC, async () => {
      try {
        // Sync offline data when connection is restored
        await this.syncOfflineData();
        
        // Update app data from server
        await this.syncDataFromServer();

        return BackgroundTask.BackgroundTaskResult.NewData;
      } catch (error) {
        console.error('Data sync task failed:', error);
        return BackgroundTask.BackgroundTaskResult.Failed;
      }
    });

    this.registeredTasks.add(BACKGROUND_TASKS.DATA_SYNC);
  }

  async startLocationTracking(mode: 'active' | 'passive' | 'emergency' = 'passive'): Promise<void> {
    if (this.isLocationTrackingActive) {
      return;
    }

    // Adjust location config based on mode
    switch (mode) {
      case 'emergency':
        this.locationConfig = {
          accuracy: Location.Accuracy.BestForNavigation,
          timeInterval: 10000, // 10 seconds
          distanceInterval: 25, // 25 meters
        };
        break;
      case 'active':
        this.locationConfig = {
          accuracy: Location.Accuracy.High,
          timeInterval: 60000, // 1 minute
          distanceInterval: 50, // 50 meters
        };
        break;
      case 'passive':
      default:
        this.locationConfig = {
          accuracy: Location.Accuracy.Balanced,
          timeInterval: 300000, // 5 minutes
          distanceInterval: 100, // 100 meters
        };
    }

    try {
      await BackgroundTask.startTaskAsync(BACKGROUND_TASKS.LOCATION_TRACKING, {
        interval: this.locationConfig.timeInterval,
      });
      
      this.isLocationTrackingActive = true;
      console.log(`Location tracking started in ${mode} mode`);
    } catch (error) {
      console.error('Failed to start location tracking:', error);
    }
  }

  async stopLocationTracking(): Promise<void> {
    if (!this.isLocationTrackingActive) {
      return;
    }

    try {
      await BackgroundTask.stopTaskAsync(BACKGROUND_TASKS.LOCATION_TRACKING);
      this.isLocationTrackingActive = false;
      console.log('Location tracking stopped');
    } catch (error) {
      console.error('Failed to stop location tracking:', error);
    }
  }

  private async checkEmergencyConditions(location: Location.LocationObject): Promise<void> {
    const state = store.getState();
    const { lastKnownLocation, emergencySettings } = state.emergency;

    // Check for significant movement deviation
    if (lastKnownLocation && emergencySettings.automaticDetection) {
      const distance = this.calculateDistance(
        lastKnownLocation.latitude,
        lastKnownLocation.longitude,
        location.coords.latitude,
        location.coords.longitude
      );

      // If user moves more than 5km in 5 minutes, it might be an emergency
      const timeDiff = location.timestamp - lastKnownLocation.timestamp;
      const speedKmh = (distance / 1000) / (timeDiff / 3600000);

      if (speedKmh > 60 && !state.emergency.expectedHighSpeedTravel) {
        await this.triggerAutomaticEmergency('high_speed_movement', location);
      }
    }
  }

  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const R = 6371e3; // Earth's radius in meters
    const φ1 = lat1 * Math.PI/180;
    const φ2 = lat2 * Math.PI/180;
    const Δφ = (lat2-lat1) * Math.PI/180;
    const Δλ = (lon2-lon1) * Math.PI/180;

    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
  }

  private async triggerAutomaticEmergency(reason: string, location: Location.LocationObject): Promise<void> {
    try {
      // Trigger emergency alert through API
      await store.dispatch(api.endpoints.triggerEmergency.initiate({
        alertType: 'automatic',
        triggerMethod: 'auto',
        location: {
          latitude: location.coords.latitude,
          longitude: location.coords.longitude,
          accuracy: location.coords.accuracy,
        },
        message: `Automatic emergency detected: ${reason}`,
      }));

      // Send local notification
      await Notifications.scheduleNotificationAsync({
        content: {
          title: '🚨 Emergency Alert Triggered',
          body: 'Automatic emergency detection activated. Your contacts have been notified.',
          categoryIdentifier: 'emergency',
        },
        trigger: null, // Immediate
      });

    } catch (error) {
      console.error('Failed to trigger automatic emergency:', error);
    }
  }
}

const getBatteryLevel = async (): Promise<number> => {
  // Implementation depends on available battery API
  // This is a placeholder
  return 0.5;
};

export const backgroundTaskManager = new BackgroundTaskManager();
```
</CodeGroup>

## Performance Optimization

### Battery & Performance Configuration

<CodeGroup>
```typescript Performance Manager
// lib/performance/manager.ts
import { store } from '../store';
import { backgroundTaskManager } from '../background/tasks';

interface PerformanceConfig {
  batteryOptimization: boolean;
  adaptivePolling: boolean;
  backgroundSync: boolean;
  locationAccuracy: 'high' | 'balanced' | 'low';
}

class PerformanceManager {
  private config: PerformanceConfig = {
    batteryOptimization: true,
    adaptivePolling: true,
    backgroundSync: true,
    locationAccuracy: 'balanced',
  };

  private batteryThresholds = {
    critical: 15, // 15%
    low: 30,      // 30%
    normal: 50,   // 50%
  };

  async optimizeForBatteryLevel(batteryLevel: number): Promise<void> {
    if (batteryLevel <= this.batteryThresholds.critical) {
      await this.enablePowerSavingMode();
    } else if (batteryLevel <= this.batteryThresholds.low) {
      await this.enableBatteryOptimization();
    } else if (batteryLevel >= this.batteryThresholds.normal) {
      await this.enableFullPerformanceMode();
    }
  }

  private async enablePowerSavingMode(): Promise<void> {
    console.log('Enabling power saving mode');
    
    // Reduce location polling frequency
    this.config.locationAccuracy = 'low';
    
    // Stop non-critical background tasks
    await backgroundTaskManager.stopLocationTracking();
    
    // Start with very reduced frequency
    await backgroundTaskManager.startLocationTracking('passive');
    
    // Disable non-critical features
    this.config.backgroundSync = false;
    
    // Update store
    store.dispatch({
      type: 'settings/updatePerformanceMode',
      payload: 'power_saving',
    });
  }

  private async enableBatteryOptimization(): Promise<void> {
    console.log('Enabling battery optimization');
    
    this.config.locationAccuracy = 'balanced';
    this.config.backgroundSync = true;
    
    // Adaptive polling based on activity
    if (this.config.adaptivePolling) {
      await this.enableAdaptivePolling();
    }
    
    store.dispatch({
      type: 'settings/updatePerformanceMode',
      payload: 'optimized',
    });
  }

  private async enableFullPerformanceMode(): Promise<void> {
    console.log('Enabling full performance mode');
    
    this.config.locationAccuracy = 'high';
    this.config.backgroundSync = true;
    this.config.adaptivePolling = true;
    
    store.dispatch({
      type: 'settings/updatePerformanceMode',
      payload: 'full',
    });
  }

  private async enableAdaptivePolling(): Promise<void> {
    const state = store.getState();
    const { isEmergencyActive, isLocationSharingActive } = state.emergency;
    
    if (isEmergencyActive) {
      await backgroundTaskManager.startLocationTracking('emergency');
    } else if (isLocationSharingActive) {
      await backgroundTaskManager.startLocationTracking('active');
    } else {
      await backgroundTaskManager.startLocationTracking('passive');
    }
  }

  async handleAppStateChange(nextAppState: string): Promise<void> {
    switch (nextAppState) {
      case 'background':
        await this.optimizeForBackground();
        break;
      case 'active':
        await this.optimizeForForeground();
        break;
      case 'inactive':
        // Do nothing, transitional state
        break;
    }
  }

  private async optimizeForBackground(): Promise<void> {
    // Reduce update frequency when app is in background
    const state = store.getState();
    const { isEmergencyActive } = state.emergency;
    
    if (!isEmergencyActive) {
      // Switch to passive mode for better battery life
      await backgroundTaskManager.startLocationTracking('passive');
    }
  }

  private async optimizeForForeground(): Promise<void> {
    // Resume full functionality when app is active
    const state = store.getState();
    const { isLocationSharingActive, isEmergencyActive } = state.emergency;
    
    if (isEmergencyActive) {
      await backgroundTaskManager.startLocationTracking('emergency');
    } else if (isLocationSharingActive) {
      await backgroundTaskManager.startLocationTracking('active');
    }
  }

  getPerformanceMetrics(): any {
    // Return current performance metrics
    return {
      config: this.config,
      batteryThresholds: this.batteryThresholds,
      // Add more metrics as needed
    };
  }
}

export const performanceManager = new PerformanceManager();
```
</CodeGroup>

## Testing Configuration

### E2E Testing with Detox

<CodeGroup>
```json Detox Configuration
{
  "detox": {
    "testRunner": {
      "args": {
        "config": "e2e/jest.config.js",
        "maxWorkers": 1
      },
      "jest": {
        "setupFilesAfterEnv": ["<rootDir>/e2e/init.js"]
      }
    },
    "apps": {
      "ios.debug": {
        "type": "ios.app",
        "binaryPath": "ios/build/Build/Products/Debug-iphonesimulator/ShelterSafetyApp.app",
        "build": "xcodebuild -workspace ios/ShelterSafetyApp.xcworkspace -scheme ShelterSafetyApp -configuration Debug -sdk iphonesimulator -derivedDataPath ios/build"
      },
      "ios.release": {
        "type": "ios.app",
        "binaryPath": "ios/build/Build/Products/Release-iphonesimulator/ShelterSafetyApp.app",
        "build": "xcodebuild -workspace ios/ShelterSafetyApp.xcworkspace -scheme ShelterSafetyApp -configuration Release -sdk iphonesimulator -derivedDataPath ios/build"
      },
      "android.debug": {
        "type": "android.apk",
        "binaryPath": "android/app/build/outputs/apk/debug/app-debug.apk",
        "build": "cd android && ./gradlew assembleDebug assembleAndroidTest -DtestBuildType=debug",
        "reversePorts": [8081]
      },
      "android.release": {
        "type": "android.apk",
        "binaryPath": "android/app/build/outputs/apk/release/app-release.apk",
        "build": "cd android && ./gradlew assembleRelease assembleAndroidTest -DtestBuildType=release"
      }
    },
    "devices": {
      "simulator": {
        "type": "ios.simulator",
        "device": {
          "type": "iPhone 15 Pro"
        }
      },
      "emulator": {
        "type": "android.emulator",
        "device": {
          "avdName": "Pixel_7_API_34"
        }
      }
    },
    "configurations": {
      "ios.sim.debug": {
        "device": "simulator",
        "app": "ios.debug"
      },
      "ios.sim.release": {
        "device": "simulator",
        "app": "ios.release"
      },
      "android.emu.debug": {
        "device": "emulator",
        "app": "android.debug"
      },
      "android.emu.release": {
        "device": "emulator",
        "app": "android.release"
      }
    }
  }
}
```

```javascript Emergency Feature E2E Tests
// e2e/emergencyFeatures.test.js
import { device, expect, element, by, waitFor } from 'detox';

describe('Emergency Features', () => {
  beforeEach(async () => {
    await device.reloadReactNative();
    // Navigate to emergency screen
    await element(by.id('emergency-tab')).tap();
  });

  afterEach(async () => {
    // Clean up any triggered alerts
    await device.sendToHome();
  });

  it('should trigger emergency alert with button press', async () => {
    // Test manual emergency trigger
    await element(by.id('emergency-button')).tap();
    
    // Should show confirmation dialog
    await waitFor(element(by.id('emergency-confirmation')))
      .toBeVisible()
      .withTimeout(2000);
    
    await element(by.id('confirm-emergency')).tap();
    
    // Should show alert triggered screen
    await waitFor(element(by.id('emergency-active')))
      .toBeVisible()
      .withTimeout(5000);
    
    // Should display contacts being notified
    await expect(element(by.id('contacts-notified'))).toBeVisible();
  });

  it('should handle emergency resolution', async () => {
    // First trigger an emergency
    await element(by.id('emergency-button')).tap();
    await element(by.id('confirm-emergency')).tap();
    
    await waitFor(element(by.id('emergency-active')))
      .toBeVisible()
      .withTimeout(5000);
    
    // Resolve the emergency
    await element(by.id('resolve-emergency')).tap();
    await element(by.id('confirm-resolved')).tap();
    
    // Should return to normal state
    await waitFor(element(by.id('emergency-button')))
      .toBeVisible()
      .withTimeout(3000);
    
    await expect(element(by.id('emergency-active'))).not.toBeVisible();
  });

  it('should test shake gesture emergency trigger', async () => {
    // Enable shake detection in settings
    await element(by.id('settings-tab')).tap();
    await element(by.id('shake-emergency-toggle')).tap();
    
    // Go back to emergency screen
    await element(by.id('emergency-tab')).tap();
    
    // Simulate shake gesture
    await device.shake();
    
    // Should show shake confirmation
    await waitFor(element(by.id('shake-confirmation')))
      .toBeVisible()
      .withTimeout(3000);
    
    await element(by.id('confirm-shake-emergency')).tap();
    
    // Should trigger emergency
    await waitFor(element(by.id('emergency-active')))
      .toBeVisible()
      .withTimeout(5000);
  });

  it('should test location sharing during emergency', async () => {
    // Trigger emergency
    await element(by.id('emergency-button')).tap();
    await element(by.id('confirm-emergency')).tap();
    
    await waitFor(element(by.id('emergency-active')))
      .toBeVisible()
      .withTimeout(5000);
    
    // Should show location sharing is active
    await expect(element(by.id('location-sharing-active'))).toBeVisible();
    
    // Should display current location
    await expect(element(by.id('current-location'))).toBeVisible();
    
    // Should show map with location pin
    await expect(element(by.id('location-map'))).toBeVisible();
  });

  it('should test emergency contacts notification', async () => {
    // Add test contact first
    await element(by.id('settings-tab')).tap();
    await element(by.id('emergency-contacts')).tap();
    await element(by.id('add-contact')).tap();
    
    await element(by.id('contact-name')).typeText('Test Contact');
    await element(by.id('contact-phone')).typeText('+1234567890');
    await element(by.id('save-contact')).tap();
    
    // Go back and trigger emergency
    await element(by.id('emergency-tab')).tap();
    await element(by.id('emergency-button')).tap();
    await element(by.id('confirm-emergency')).tap();
    
    // Should show contact notification status
    await waitFor(element(by.id('notification-status')))
      .toBeVisible()
      .withTimeout(5000);
    
    await expect(element(by.text('Test Contact - Notified'))).toBeVisible();
  });

  it('should test offline emergency functionality', async () => {
    // Disable network
    await device.setNetworkState('off');
    
    // Trigger emergency
    await element(by.id('emergency-button')).tap();
    await element(by.id('confirm-emergency')).tap();
    
    // Should show offline mode indicator
    await waitFor(element(by.id('offline-mode')))
      .toBeVisible()
      .withTimeout(3000);
    
    // Should still activate emergency mode
    await expect(element(by.id('emergency-active'))).toBeVisible();
    
    // Should show queued notifications
    await expect(element(by.id('notifications-queued'))).toBeVisible();
    
    // Re-enable network
    await device.setNetworkState('on');
    
    // Should sync queued data
    await waitFor(element(by.id('sync-complete')))
      .toBeVisible()
      .withTimeout(10000);
  });
});
```
</CodeGroup>

## Production Build Configuration

### EAS Build Configuration

<CodeGroup>
```json eas.json
{
  "cli": {
    "version": ">= 5.0.0"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "ios": {
        "resourceClass": "m-medium",
        "simulator": true
      },
      "android": {
        "resourceClass": "medium",
        "gradleCommand": ":app:assembleDebug"
      }
    },
    "preview": {
      "distribution": "internal",
      "ios": {
        "resourceClass": "m-medium"
      },
      "android": {
        "resourceClass": "medium",
        "buildType": "apk"
      }
    },
    "production": {
      "ios": {
        "resourceClass": "m-large",
        "autoIncrement": true,
        "bundleIdentifier": "com.shelther.safety"
      },
      "android": {
        "resourceClass": "large",
        "autoIncrement": "versionCode",
        "buildType": "aab"
      },
      "env": {
        "EXPO_PUBLIC_API_URL": "https://api.shelther.app",
        "EXPO_PUBLIC_WS_URL": "wss://realtime.shelther.app"
      }
    }
  },
  "submit": {
    "production": {
      "ios": {
        "appleId": "your-apple-id@example.com",
        "ascAppId": "1234567890",
        "appleTeamId": "ABCDEFGHIJ"
      },
      "android": {
        "serviceAccountKeyPath": "./service-account-key.json",
        "track": "production"
      }
    }
  }
}
```
</CodeGroup>

## Next Steps

<Note>
**Production Setup Complete!** Your Expo environment is now configured with enterprise-grade architecture, Express.js backend integration, and advanced safety features.
</Note>

<CardGroup cols={3}>
  <Card title="Express.js Backend" icon="server" href="/quickstart/express-setup">
    Set up your Express.js backend with Railway deployment and safety services
  </Card>
  <Card title="Supabase Integration" icon="database" href="/quickstart/supabase-setup">
    Configure Supabase for authentication, real-time features, and data storage
  </Card>
  <Card title="First Safety App" icon="mobile" href="/quickstart/first-app">
    Build your first production safety application with all features integrated
  </Card>
</CardGroup>

## Configuration Checklist

<Steps>
  <Step title="✅ Modern Architecture">
    React Native 0.74+ with New Architecture enabled for optimal performance
  </Step>
  <Step title="✅ Backend Integration">
    Express.js API client with JWT authentication and WebSocket connections configured
  </Step>
  <Step title="✅ State Management">
    Redux Toolkit with React Query for optimized data fetching and caching
  </Step>
  <Step title="✅ Background Services">
    Advanced background tasks with battery optimization and adaptive polling
  </Step>
  <Step title="✅ Performance Optimization">
    Battery management, adaptive polling, and performance monitoring systems
  </Step>
  <Step title="✅ Testing Framework">
    Complete testing setup with unit tests, integration tests, and E2E tests
  </Step>
  <Step title="✅ Production Builds">
    EAS Build configuration optimized for App Store and Google Play deployment
  </Step>
</Steps>

<Warning>
**Security Reminder:** This configuration includes production-ready security measures, but always review security settings before deploying to production. Implement additional hardening based on your specific security requirements.
</Warning>